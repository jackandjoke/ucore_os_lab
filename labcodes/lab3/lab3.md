## lab3
### 练习1：给未被映射的地址映射上物理页（需要编程）  
* do_pgfault 函数用来处理page fault  
* 出现page fault时，出错的逻辑地址在cr2寄存器中，出错的原因在error_code中，第0，1，2位分别表示present, writable, user/kernel  
* 查找出逻辑地址所在的vam_struct, 先排除以下失败的情况
* * 逻辑地址错误
* * 写只读区域
* * 读禁止读/禁止运行的区域  
* 但还有几个处理没理解：
* * 因为写存在区域而出错的情况不被认为是失败的情况
* * 因为读存在区域而出错的情况被认为是失败的情况
* 剩下就是正常的缺页错误
* * 首先在页目录表查找逻辑地址所在的页表是否存在，不存去新建
* * 然后在页表里查找是否有相应的页表项对应，没有，则分配一个物理页，这里没有考虑空闲物理页为0的情况  
* 这样也能通过check_pgfault()  

#### 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。  
* 页表项有present位（表示是逻辑页内容否在内存中），dirty位（是否修改过，修改过则替换时要写回swap区域），  有逻辑页号，表示当前页表项是否是正确对应于该逻辑页的，不对应的话查找下一个可能的地方

#### 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？  
* 硬件会保存出错的地址到cr2寄存器中，并且设置errorCode,压入栈  
* 然后保存当前现场，将cs,eip,等寄存器压栈，调用pgfault处理例程  
* 处理完成后恢复现场   

### 练习2：补充完成基于FIFO的页面替换算法（需要编程）  
* FIFO PRA的实现是通过双向队列
* * 将物理页加入队列尾部
* * 从队列头部取出最先进来的页作为swap 的页  
* do_pgfault的实现，在判断要swap之后，进行以下步骤
* * swap in (从swap区域读出数据，然后将数据写入swap out 的page) 
* * 将该page插入队列  
* * 更新页表
* *  设置该page所对应的虚拟地址  

#### 如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？  
* 增加dirty位和引用位的话，就可以支持  
* 被换出的的特征有：
* * 在swappable队列里
* * dirty位位0，且引用位为0
* * 没有空闲页时候换出，将逻辑页和物理帧对应时，换入  
* 
